<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Soniox Async Transcriber</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --bg-panel: rgba(15, 23, 42, 0.75);
      --bg-panel-light: rgba(248, 250, 252, 0.95);
      --fg: #e2e8f0;
      --fg-dark: #0f172a;
      --accent: #38bdf8;
      --accent-strong: #0ea5e9;
      --border: rgba(148, 163, 184, 0.35);
      --danger: #f43f5e;
      --success: #22c55e;
      --font-stack: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont,
        "Helvetica Neue", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font-stack);
      min-height: 100vh;
      background: linear-gradient(135deg, #0f172a 0%, #1f2937 45%, #020617 100%);
      color: var(--fg);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(1rem, 2vw + 1rem, 3rem);
    }

    main {
      width: min(100%, 1100px);
      display: grid;
      gap: clamp(1rem, 1.5vw, 1.75rem);
    }

    header {
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: clamp(1.5rem, 2vw, 2.5rem);
      box-shadow: 0 30px 80px rgba(8, 47, 73, 0.35);
    }

    header h1 {
      margin: 0 0 0.75rem;
      font-size: clamp(1.8rem, 3vw, 2.6rem);
      font-weight: 700;
      letter-spacing: -0.03em;
    }

    header p {
      margin: 0;
      line-height: 1.6;
      color: rgba(226, 232, 240, 0.78);
      font-size: clamp(1rem, 1.2vw, 1.1rem);
    }

    .panels {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: clamp(1rem, 1.3vw, 1.5rem);
    }

    .panel {
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: clamp(1.3rem, 2vw, 2rem);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 20px 50px rgba(8, 47, 73, 0.28);
    }

    @media (prefers-color-scheme: light) {
      body {
        background: radial-gradient(circle at top, #e0f2fe 0%, #f8fafc 50%, #e2e8f0 100%);
        color: var(--fg-dark);
      }
      header,
      .panel {
        background: var(--bg-panel-light);
        color: var(--fg-dark);
        border-color: rgba(15, 23, 42, 0.08);
        box-shadow: 0 25px 50px rgba(15, 23, 42, 0.15);
      }
      header p {
        color: rgba(15, 23, 42, 0.65);
      }
    }

    h2 {
      margin: 0;
      font-size: clamp(1.2rem, 1.7vw, 1.4rem);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    h2 .tag {
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      background: rgba(56, 189, 248, 0.15);
      color: var(--accent);
      border: 1px solid rgba(56, 189, 248, 0.45);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    fieldset {
      border: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 1rem;
    }

    label {
      font-weight: 600;
      font-size: 0.95rem;
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
    }

    label span.description {
      font-weight: 400;
      font-size: 0.9rem;
      color: rgba(226, 232, 240, 0.72);
    }

    input[type="file"] {
      display: none;
    }

    .file-drop {
      border: 2px dashed rgba(148, 163, 184, 0.4);
      border-radius: 16px;
      padding: clamp(1.5rem, 2vw, 2.5rem);
      text-align: center;
      display: grid;
      gap: 0.6rem;
      align-items: center;
      justify-items: center;
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease;
      cursor: pointer;
      background: rgba(15, 23, 42, 0.25);
    }

    .file-drop strong {
      font-size: 1.1rem;
    }

    .file-drop span {
      font-size: 0.9rem;
      color: rgba(226, 232, 240, 0.7);
    }

    .file-drop:hover,
    .file-drop.dragging {
      border-color: rgba(14, 165, 233, 0.75);
      background: rgba(14, 116, 144, 0.18);
      transform: translateY(-2px);
    }

    .source-divider {
      display: flex;
      align-items: center;
      gap: 1rem;
      color: rgba(226, 232, 240, 0.55);
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
    }

    .source-divider::before,
    .source-divider::after {
      content: "";
      flex: 1;
      height: 1px;
      background: rgba(148, 163, 184, 0.25);
    }

    input[type="url"],
    input[type="text"],
    input[type="password"],
    textarea,
    select {
      width: 100%;
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 12px;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      background: rgba(15, 23, 42, 0.4);
      color: inherit;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      resize: vertical;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: rgba(56, 189, 248, 0.75);
      box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.25);
    }

    textarea {
      min-height: 120px;
    }

    .switch {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.9rem 1.1rem;
      border-radius: 14px;
      background: rgba(15, 23, 42, 0.4);
      border: 1px solid rgba(148, 163, 184, 0.3);
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .switch:hover {
      border-color: rgba(56, 189, 248, 0.55);
      background: rgba(14, 116, 144, 0.2);
    }

    .switch .toggle {
      position: relative;
      width: 52px;
      height: 28px;
    }

    .switch input[type="checkbox"] {
      opacity: 0;
      width: 52px;
      height: 28px;
      position: absolute;
      inset: 0;
      margin: 0;
      cursor: pointer;
    }

    .switch input[type="checkbox"] + span {
      position: absolute;
      inset: 0;
      background: rgba(148, 163, 184, 0.4);
      border-radius: 20px;
      transition: background 0.2s ease;
    }

    .switch input[type="checkbox"] + span::after {
      content: "";
      position: absolute;
      top: 4px;
      left: 4px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #fff;
      transition: transform 0.2s ease;
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.3);
    }

    .switch input[type="checkbox"]:checked + span {
      background: linear-gradient(120deg, var(--accent) 0%, var(--accent-strong) 100%);
    }

    .switch input[type="checkbox"]:checked + span::after {
      transform: translateX(24px);
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    button {
      border: none;
      border-radius: 12px;
      padding: 0.8rem 1.6rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.6rem;
      background: linear-gradient(120deg, var(--accent) 0%, var(--accent-strong) 100%);
      color: #0f172a;
      box-shadow: 0 12px 40px rgba(14, 165, 233, 0.4);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 45px rgba(14, 165, 233, 0.55);
    }

    button.secondary {
      background: rgba(148, 163, 184, 0.15);
      color: inherit;
      box-shadow: none;
    }

    button.secondary:hover {
      background: rgba(148, 163, 184, 0.25);
      transform: none;
    }

    progress {
      width: 100%;
      height: 12px;
      border-radius: 8px;
      overflow: hidden;
      background: rgba(148, 163, 184, 0.2);
    }

    progress::-webkit-progress-bar {
      background: rgba(148, 163, 184, 0.2);
      border-radius: 8px;
    }

    progress::-webkit-progress-value {
      background: linear-gradient(120deg, var(--accent) 0%, var(--accent-strong) 100%);
      border-radius: 8px;
    }

    progress::-moz-progress-bar {
      background: linear-gradient(120deg, var(--accent) 0%, var(--accent-strong) 100%);
      border-radius: 8px;
    }

    .progress-group {
      display: grid;
      gap: 0.5rem;
    }

    .progress-group .meta {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: rgba(226, 232, 240, 0.7);
    }

    .progress-group .meta strong {
      font-weight: 600;
      color: inherit;
    }

    .progress-group .meta span.status {
      font-family: "JetBrains Mono", "Fira Code", monospace;
      letter-spacing: 0.02em;
    }

    .progress-indeterminate {
      position: relative;
      overflow: hidden;
      background: rgba(148, 163, 184, 0.2);
    }

    .progress-indeterminate::after {
      content: "";
      position: absolute;
      left: -40%;
      top: 0;
      width: 40%;
      height: 100%;
      background: linear-gradient(120deg, rgba(56, 189, 248, 0.1) 0%, rgba(56, 189, 248, 0.6) 50%, rgba(56, 189, 248, 0.1) 100%);
      animation: shimmer 1.2s infinite;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(260%);
      }
    }

    .status-log {
      max-height: 240px;
      overflow-y: auto;
      font-size: 0.9rem;
      padding-right: 0.5rem;
      scrollbar-color: rgba(148, 163, 184, 0.45) transparent;
    }

    .status-log ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 0.5rem;
    }

    .status-log li {
      background: rgba(15, 23, 42, 0.45);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 10px;
      padding: 0.75rem 0.9rem;
      line-height: 1.4;
      display: grid;
      gap: 0.25rem;
    }

    .status-log time {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(148, 163, 184, 0.65);
    }

    .status-log .info {
      color: rgba(226, 232, 240, 0.85);
    }

    .status-log .error {
      color: #fca5a5;
    }

    .status-log .success {
      color: #bbf7d0;
    }

    .results {
      display: grid;
      gap: 1rem;
    }

    .results textarea {
      min-height: 200px;
      font-family: "JetBrains Mono", "Fira Code", monospace;
      font-size: 0.95rem;
      line-height: 1.6;
    }

    .results pre {
      background: rgba(15, 23, 42, 0.45);
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 1rem;
      font-family: "JetBrains Mono", "Fira Code", monospace;
      max-height: 260px;
      overflow: auto;
      margin: 0;
      font-size: 0.9rem;
    }

    .helper {
      font-size: 0.85rem;
      color: rgba(226, 232, 240, 0.7);
    }

    .inline-grid {
      display: grid;
      gap: 0.75rem;
    }

    @media (max-width: 720px) {
      body {
        padding: 1rem;
      }
      .panels {
        grid-template-columns: 1fr;
      }
      header,
      .panel {
        padding: 1.15rem;
      }
      button {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>Soniox Async Transcriber</h1>
      <p>
        Асинхронная транскрибация локальных MP3 файлов и удалённых аудио по ссылке при помощи
        <strong>Soniox API</strong>. Интерфейс поддерживает автоопределение языка, диаризацию
        говорящих и пользовательский контекст.
      </p>
    </header>

    <form id="transcribe-form" class="panel" autocomplete="off">
      <h2>1. Источник аудио</h2>
      <fieldset>
        <label class="file-drop" id="file-drop">
          <input type="file" id="audio-file" accept="audio/mpeg,audio/mp3,audio/*" />
          <strong>Выберите MP3 или перетащите файл сюда</strong>
          <span>Основной способ — локальная загрузка.</span>
          <span class="helper" id="file-hint">Файл не выбран</span>
        </label>
        <div class="source-divider">или</div>
        <label>
          <span>Ссылка на аудио (запасной вариант)</span>
          <input type="url" id="audio-url" placeholder="https://example.com/audio.mp3" />
          <span class="helper">Если заполнено, будет использован URL вместо локального файла.</span>
        </label>
      </fieldset>

      <h2>2. Настройки</h2>
      <fieldset class="inline-grid">
        <label>
          <span>Модель</span>
          <select id="model">
            <option value="stt-async-preview" selected>stt-async-preview</option>
          </select>
        </label>
        <div class="switch">
          <div>
            <strong>Language Identification</strong>
            <span class="helper">Автоопределение языка речи</span>
          </div>
          <div class="toggle">
            <input type="checkbox" id="lid" checked />
            <span></span>
          </div>
        </div>
        <div class="switch">
          <div>
            <strong>Speaker Diarization</strong>
            <span class="helper">Разделение по говорящим</span>
          </div>
          <div class="toggle">
            <input type="checkbox" id="diarization" checked />
            <span></span>
          </div>
        </div>
        <label>
          <span>Context</span>
          <textarea id="context" placeholder="слово 1, фраза 2, имя 3"></textarea>
          <span class="helper">Слова и фразы через запятую для улучшения распознавания.</span>
        </label>
        <label>
          <span>API Key</span>
          <input type="password" id="api-key" value="52556d484ae68cc14495a6620786e4a9563dccf579aa95633609cdeda3fdb9c9" required />
          <span class="helper">Ключ хранится только в браузере. При необходимости измените.</span>
        </label>
      </fieldset>

      <div class="actions">
        <button type="submit" id="start-btn">Начать транскрибацию</button>
        <button type="button" class="secondary" id="reset-btn">Сбросить форму</button>
      </div>
    </form>

    <section class="panel">
      <h2>3. Статус</h2>
      <div class="progress-group">
        <div class="meta">
          <strong>Загрузка файла</strong>
          <span class="status" id="upload-status">Ожидание</span>
        </div>
        <progress id="upload-progress" max="100" value="0"></progress>
      </div>
      <div class="progress-group">
        <div class="meta">
          <strong>Транскрибация</strong>
          <span class="status" id="transcribe-status">Ожидание</span>
        </div>
        <progress id="transcribe-progress" max="100" value="0"></progress>
      </div>
    </section>

    <section class="panel results">
      <h2>4. Результат</h2>
      <label>
        <span>Текст</span>
        <textarea id="text-output" readonly placeholder="Результат появится здесь"></textarea>
      </label>
      <label>
        <span>JSON</span>
        <pre id="json-output">—</pre>
      </label>
      <div class="actions">
        <button type="button" class="secondary" id="download-text" disabled>Скачать текст</button>
        <button type="button" class="secondary" id="download-json" disabled>Скачать JSON</button>
      </div>
    </section>

    <section class="panel status-log">
      <h2>5. Журнал</h2>
      <ul id="status-log"></ul>
    </section>
  </main>

  <script>
    const API_BASE = "https://api.soniox.com/v1";
    const form = document.getElementById("transcribe-form");
    const fileDrop = document.getElementById("file-drop");
    const fileInput = document.getElementById("audio-file");
    const fileHint = document.getElementById("file-hint");
    const urlInput = document.getElementById("audio-url");
    const modelSelect = document.getElementById("model");
    const lidCheckbox = document.getElementById("lid");
    const diarizationCheckbox = document.getElementById("diarization");
    const contextInput = document.getElementById("context");
    const apiKeyInput = document.getElementById("api-key");
    const startButton = document.getElementById("start-btn");
    const resetButton = document.getElementById("reset-btn");

    const uploadProgress = document.getElementById("upload-progress");
    const uploadStatus = document.getElementById("upload-status");
    const transcribeProgress = document.getElementById("transcribe-progress");
    const transcribeStatus = document.getElementById("transcribe-status");

    const textOutput = document.getElementById("text-output");
    const jsonOutput = document.getElementById("json-output");
    const downloadTextBtn = document.getElementById("download-text");
    const downloadJsonBtn = document.getElementById("download-json");
    const statusLog = document.getElementById("status-log");

    let pollIntervalId = null;

    function resetProgress() {
      updateUploadProgress(0, "Ожидание");
      updateTranscriptionProgress(0, "Ожидание", false);
      textOutput.value = "";
      jsonOutput.textContent = "—";
      downloadTextBtn.disabled = true;
      downloadJsonBtn.disabled = true;
    }

    function resetForm() {
      form.reset();
      modelSelect.value = "stt-async-preview";
      lidCheckbox.checked = true;
      diarizationCheckbox.checked = true;
      contextInput.value = "";
      fileHint.textContent = "Файл не выбран";
      stopPolling();
      resetProgress();
      clearStatusLog();
    }

    function clearStatusLog() {
      statusLog.innerHTML = "";
    }

    function logStatus(message, type = "info") {
      const item = document.createElement("li");
      const time = document.createElement("time");
      time.dateTime = new Date().toISOString();
      time.textContent = new Intl.DateTimeFormat("ru-RU", {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      }).format(new Date());

      const text = document.createElement("div");
      text.className = type;
      text.textContent = message;

      item.append(time, text);
      statusLog.prepend(item);
    }

    function updateUploadProgress(value, status) {
      uploadProgress.value = value;
      uploadStatus.textContent = status;
    }

    function updateTranscriptionProgress(value, status, indeterminate = false) {
      if (indeterminate) {
        transcribeProgress.classList.add("progress-indeterminate");
        transcribeProgress.removeAttribute("value");
      } else {
        transcribeProgress.classList.remove("progress-indeterminate");
        transcribeProgress.value = value;
      }
      transcribeStatus.textContent = status;
    }

    function parseContext(raw) {
      return raw
        .split(",")
        .map((item) => item.trim())
        .filter(Boolean);
    }

    function getPayload() {
      const context = parseContext(contextInput.value || "");
      return {
        model: modelSelect.value,
        enable_language_identification: lidCheckbox.checked,
        enable_speaker_diarization: diarizationCheckbox.checked,
        context: context
      };
    }

    function stopPolling() {
      if (pollIntervalId) {
        clearInterval(pollIntervalId);
        pollIntervalId = null;
      }
    }

    function applyResultText(data) {
      const transcript = extractTranscriptText(data);
      if (transcript) {
        textOutput.value = transcript;
      } else {
        textOutput.value = "";
      }
      jsonOutput.textContent = JSON.stringify(data, null, 2);
      downloadTextBtn.disabled = !transcript;
      downloadJsonBtn.disabled = false;
    }

    function extractTranscriptText(data) {
      if (!data || typeof data !== "object") return "";
      if (typeof data.text === "string") return data.text;
      if (data.result && typeof data.result.text === "string") return data.result.text;
      if (data.transcription && typeof data.transcription.text === "string") return data.transcription.text;
      if (data.results && Array.isArray(data.results)) {
        return data.results
          .map((block) => block.text || (block.words ? block.words.map((w) => w.text).join(" ") : ""))
          .join(" \n");
      }
      if (Array.isArray(data.words)) {
        return data.words.map((w) => w.text).join(" ");
      }
      return "";
    }

    function validateSource(file, url) {
      if (!file && !url) {
        throw new Error("Выберите локальный файл или укажите ссылку на аудио.");
      }
      if (file && url) {
        logStatus("Выбран файл, ссылка будет проигнорирована.");
      }
    }

    function createHeaders(apiKey, extra = {}) {
      return {
        Authorization: `Bearer ${apiKey}`,
        ...extra
      };
    }

    async function sendUrlJob(apiKey, payload, audioUrl) {
      updateUploadProgress(100, "URL подготовлен");
      const requestBody = {
        audio_url: audioUrl,
        ...payload
      };
      logStatus("Отправляем запрос на асинхронную транскрибацию по URL...");
      const response = await fetch(`${API_BASE}/async/transcribe`, {
        method: "POST",
        headers: createHeaders(apiKey, { "Content-Type": "application/json" }),
        body: JSON.stringify(requestBody)
      });
      if (!response.ok) {
        const text = await response.text();
        throw new Error(`Ошибка при создании задания: ${response.status} ${response.statusText} — ${text}`);
      }
      const data = await response.json();
      return data.job_id || data.id || data.jobId || data.job?.id;
    }

    function sendFileJob(apiKey, payload, file) {
      return new Promise((resolve, reject) => {
        const formData = new FormData();
        formData.append("audio_file", file, file.name);
        formData.append("options", JSON.stringify(payload));

        const xhr = new XMLHttpRequest();
        xhr.open("POST", `${API_BASE}/async/transcribe`);
        xhr.setRequestHeader("Authorization", `Bearer ${apiKey}`);

        xhr.upload.onprogress = (event) => {
          if (event.lengthComputable) {
            const percent = Math.round((event.loaded / event.total) * 100);
            updateUploadProgress(percent, `Загружено ${percent}%`);
          } else {
            updateUploadProgress(50, "Загрузка...");
          }
        };

        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) {
            updateUploadProgress(100, "Загружено");
            try {
              const data = JSON.parse(xhr.responseText || "{}");
              const jobId = data.job_id || data.id || data.jobId || data.job?.id;
              if (jobId) {
                resolve(jobId);
              } else {
                reject(new Error("Не удалось получить идентификатор задания."));
              }
            } catch (error) {
              reject(new Error("Неверный формат ответа сервера."));
            }
          } else {
            reject(new Error(`Ошибка при загрузке файла: ${xhr.status} ${xhr.statusText}`));
          }
        };

        xhr.onerror = () => reject(new Error("Ошибка сети при загрузке файла."));
        xhr.send(formData);
        logStatus("Загружаем файл на сервер Soniox...");
      });
    }

    async function pollForResult(apiKey, jobId) {
      stopPolling();
      logStatus(`Создано задание ${jobId}. Ожидание результата...`);
      updateTranscriptionProgress(5, "В обработке", true);

      const pollEndpointCandidates = [
        `${API_BASE}/async/transcribe/${jobId}`,
        `${API_BASE}/async/transcribe?job_id=${encodeURIComponent(jobId)}`,
        `${API_BASE}/async/jobs/${jobId}`
      ];

      let candidateIndex = 0;

      const poll = async () => {
        const endpoint = pollEndpointCandidates[candidateIndex] || pollEndpointCandidates[0];
        try {
          const response = await fetch(endpoint, {
            headers: createHeaders(apiKey)
          });

          if (response.status === 404 && candidateIndex < pollEndpointCandidates.length - 1) {
            candidateIndex += 1;
            return;
          }

          if (!response.ok) {
            throw new Error(`Статус ${response.status}`);
          }

          const data = await response.json();
          handlePollResponse(data);
        } catch (error) {
          logStatus(`Ошибка при опросе: ${error.message}`, "error");
        }
      };

      pollIntervalId = setInterval(poll, 3500);
      await poll();
    }

    function handlePollResponse(data) {
      const status =
        data.status ||
        data.job_status ||
        data.processing_status ||
        data.job?.status ||
        data.state;

      const progress =
        data.progress_percent ??
        data.progress ??
        data.job?.progress_percent ??
        data.job?.progress;

      if (typeof progress === "number" && progress >= 0 && progress <= 100) {
        updateTranscriptionProgress(progress, `${progress}%`, false);
      } else if (status && status.toLowerCase() === "in_progress") {
        updateTranscriptionProgress(50, "В работе", true);
      }

      if (!status) return;

      switch (status.toLowerCase()) {
        case "queued":
          updateTranscriptionProgress(10, "В очереди", true);
          break;
        case "in_progress":
        case "processing":
          updateTranscriptionProgress(progress || 60, "Обработка", !progress);
          break;
        case "completed":
        case "done":
        case "succeeded":
          stopPolling();
          updateTranscriptionProgress(100, "Готово");
          applyResultText(data.result || data.transcription || data);
          logStatus("Транскрибация завершена успешно", "success");
          break;
        case "failed":
        case "error":
          stopPolling();
          updateTranscriptionProgress(0, "Ошибка");
          logStatus("Транскрибация завершилась ошибкой.", "error");
          break;
        default:
          updateTranscriptionProgress(50, status, true);
      }
    }

    form.addEventListener("submit", async (event) => {
      event.preventDefault();
      stopPolling();
      resetProgress();

      const apiKey = apiKeyInput.value.trim();
      const file = fileInput.files[0] || null;
      const audioUrl = urlInput.value.trim();

      try {
        if (!apiKey) {
          throw new Error("Укажите API ключ Soniox.");
        }
        validateSource(file, audioUrl);
        startButton.disabled = true;
        startButton.textContent = "Отправляем...";
        logStatus("Подготовка задания...");

        const payload = getPayload();
        let jobId;

        if (file) {
          jobId = await sendFileJob(apiKey, payload, file);
        } else {
          jobId = await sendUrlJob(apiKey, payload, audioUrl);
        }

        if (!jobId) {
          throw new Error("Сервер не вернул идентификатор задания.");
        }

        await pollForResult(apiKey, jobId);
      } catch (error) {
        logStatus(error.message, "error");
        updateUploadProgress(0, "Ошибка");
        updateTranscriptionProgress(0, "Ошибка");
      } finally {
        startButton.disabled = false;
        startButton.textContent = "Начать транскрибацию";
      }
    });

    resetButton.addEventListener("click", () => {
      resetForm();
      logStatus("Форма сброшена");
    });

    fileInput.addEventListener("change", () => {
      const file = fileInput.files[0];
      if (file) {
        fileHint.textContent = `${file.name} (${(file.size / 1024 / 1024).toFixed(2)} МБ)`;
        logStatus(`Выбран файл: ${file.name}`);
      } else {
        fileHint.textContent = "Файл не выбран";
      }
    });

    ["dragenter", "dragover"].forEach((eventName) => {
      fileDrop.addEventListener(eventName, (event) => {
        event.preventDefault();
        event.stopPropagation();
        fileDrop.classList.add("dragging");
      });
    });

    ["dragleave", "drop"].forEach((eventName) => {
      fileDrop.addEventListener(eventName, (event) => {
        event.preventDefault();
        event.stopPropagation();
        fileDrop.classList.remove("dragging");
      });
    });

    fileDrop.addEventListener("drop", (event) => {
      const file = event.dataTransfer.files[0];
      if (file) {
        fileInput.files = event.dataTransfer.files;
        fileInput.dispatchEvent(new Event("change"));
      }
    });

    downloadTextBtn.addEventListener("click", () => {
      if (!textOutput.value.trim()) return;
      downloadBlob(textOutput.value, "transcription.txt", "text/plain");
    });

    downloadJsonBtn.addEventListener("click", () => {
      if (jsonOutput.textContent === "—") return;
      downloadBlob(jsonOutput.textContent, "transcription.json", "application/json");
    });

    function downloadBlob(content, filename, type) {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    resetProgress();
    logStatus("Готово к работе");
  </script>
</body>
</html>
